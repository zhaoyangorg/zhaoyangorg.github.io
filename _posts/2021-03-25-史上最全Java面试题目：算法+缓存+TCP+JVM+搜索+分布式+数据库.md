---
layout:     post
title:      史上最全Java面试题目：算法+缓存+TCP+JVM+搜索+分布式+数据库
subtitle:   面试准备
date:       2021-03-25
author:     zhaoyang
header-img: img/starry-sky.jpg
catalog: true
tags:
    - interview
---


## 前言

原文[史上最全Java面试题目：算法+缓存+TCP+JVM+搜索+分布式+数据库](http://k6k4.com/blog/show/aaazl3yz31536803138663)

## 正文

**JAVA基础**

1. JAVA中的几种基本数据类型是什么，各自占用多少字节。

1字节=8bit（位）

| 基本类型 | 字节 | 
| :---- | :---- |
| boolean | 1bit 不到一个字节 |
| byte | 8bit 1字节 |
| short | 16bit 2字节 |
| char | 16bit 2字节 |
| int | 32bit 4字节 |
| float | 32bit 4字节 |
| double | 64bit 8字节 |
| long | 64bit 8字节 |

2. String类能被继承吗，为什么。

不能，因为String被final修饰，被final修饰的类不能被继承

扩展：
- String 类

public final class String implements java.io.Serializable, Comparable<String>, CharSequence 

- final 关键字   
   - 对于一个 final 变量，如果是基本数据类型的变量，则其数值一旦在初始化之后便不能更改；如果是引用类型的变量，则在对其初始化之后便不能再让其指向另一个对象。
   - 当用 final 修饰一个类时，表明这个类不能被继承。final 类中的所有成员方法都会被隐式地指定为 final 方法。
   - 使用 final 方法的原因有两个。第一个原因是把方法锁定，以防任何继承类修改它的含义；第二个原因是效率。在早期的 Java 实现版本中，会将 final 方法转为内嵌调用。但是如果方法过于庞大，可能看不到内嵌调用带来的任何性能提升（现在的 Java 版本已经不需要使用 final 方法进行这些优化了）。类中所有的 private 方法都隐式地指定为 final。
- String s = new String(“xyz”);  //创建了几个对象

String s=new String("xyz")究竟创建String Object分为两种情况 

如果String常理池中，已经创建"xyz"，则不会继续创建，此时只创建了一个对象new String("xyz")

如果String常理池中，没有创建"xyz"，则会创建两个对象，一个对象的值是"xyz"，一个对象new String("xyz")。
- Java中的String为什么是不可变的
    - 因为使用final关键字
- StringBuffer, StringBuilder
    - String、StringBuffer线程安全(使用了synchronized)，StringBuilder线程不安全，但是效率高

3. ArrayList和LinkedList有什么区别。

    - ArrayList
    底层实现是动态数组；扩容过程是：默认初始长度是10，并且每次先扩大1.5倍，在跟需要的数据长度做比较，如果不够的话，以数据需要的长度为准，然后在检查期望容量是否越界，越界的话，以最大容量为准；ArrayList 还实现了 Cloneable 接口，这表明 ArrayList 是支持拷贝的；ArrayList 还实现了 Serializable 接口，标记“实现了这个接口的类支持序列化”，但是ArrayList 中的关键字段elementData 使用了 transient 关键字修饰，这个关键字的作用是，让它修饰的字段不被序列化。为什么要这样，因为序列化的时候，如果把整个数组都序列化的话，会将没有值的字段一起序列化。当存储的元素数量非常非常多的时候，闲置的空间就非常非常大，序列化耗费的时间就会非常非常多。所以arraylist内部提供了两个私有方法 writeObject 和 readObject 来完成序列化和反序列化。它使用了 ArrayList 的实际大小 size 而不是数组的长度（elementData.length）来作为元素的上限进行序列化。
    - LinkedList
    底层实现是双向链表；LinkedList 还实现了 Cloneable 接口，这表明 LinkedList 是支持拷贝的。LinkedList 还实现了 Serializable 接口，这表明 LinkedList 是支持序列化的，但是LinkedList 中的关键字段 size、first、last 都使用了 transient 关键字修饰，LinkedList 在序列化的时候只保留了元素的内容 item，并没有保留元素的前后引用。这样就节省了不少内存空间，当使用反序列化readObject()方法的时候，它可以把链表重新链接起来，这样就恢复了链表序列化之前的顺序

4. 讲讲类的实例化顺序，比如父类静态数据，构造函数，字段，子类静态数据，构造函数，字段，当new的时候，他们的执行顺序。

    - 父类静态代码块、静态变量按照代码的先后顺序执行
    - 子类静态代码块、静态变量按照代码的先后顺序执行
    - 父类非静态代码块、非静态变量按照代码先后顺序执行、构造函数
    - 子类非静态代码块、非静态变量按照代码先后顺序执行、构造函数

    - 静态代码块、静态变量只会执行一次

5. 用过哪些Map类，都有什么区别，HashMap是线程安全的吗,并发下使用的Map是什么，他们内部原理分别是什么，比如存储方式，hashcode，扩容，默认容量等。
    
    - Map类
    HashMap、LinkedHashMap、TreeMap、HashTable、ConcurrentHashMap
    - HashMap线程不安全、HashTable线程安全（Synchronized）
    - 并发下使用ConcurrentHashMap
    - HashMap底层使用数组+链表+红黑树 （当链表长度超过8的时候，转为红黑树）
    - HashMap 初始长度位16，当数组中有数据的个数超过总数的0.75时，扩容为2n
    - HashMap的并发问题，在扩容rehash中容易导致死锁

6. JAVA8的ConcurrentHashMap为什么放弃了分段锁，有什么问题吗，如果你来设计，你如何设计。

    使用节点锁，只锁表头，颗粒度更低，性能更好

7. 有没有有顺序的Map实现类，如果有，他们是怎么保证有序的。

    - LinkedHashMap（链表） 和 TreeMap（树）

8. 抽象类和接口的区别，类可以继承多个类么，接口可以继承多个接口么,类可以实现多个接口么。

    - 单继承多实现

9. IO模型有哪些，讲讲你理解的nio ，他和bio，aio的区别是啥，谈谈reactor模型。
    
    - nio ：非阻塞同步io
    - bio：阻塞同步io
    - aio：异步非阻塞io


11. 反射的原理，反射创建类实例的三种方式是什么。

    - Class.forName(类路径)
    - Object.class
    - new Object().getClass()

12. 反射中，Class.forName和ClassLoader区别。

    - Class.forName:加载+拼接
    - ClassLoader加载

13. 描述动态代理的几种实现方式，分别说出相应的优缺点。
14. 动态代理与cglib实现的区别。
    - JDK动态代理：利用拦截器(拦截器必须实现InvocationHanlder)加上反射机制生成一个实现代理接口的匿名类，在调用具体方法前调用InvokeHandler来处理。
    - 利用ASM开源包，对代理对象类的class文件加载进来，通过修改其字节码生成子类来处理，CGLib原理是动态生成被代理类的子类。
    - 何时使用JDK还是CGLIB？
        - 如果目标对象实现了接口，默认情况下会采用JDK的动态代理实现AOP
        - 如果目标对象实现了接口，可以强制使用CGLIB实现AOP
        - 如果目标对象没有实现了接口，必须采用CGLIB库，Spring会自动在JDK动态代理和CGLIB之间转换。
15. 为什么CGlib方式可以对接口实现代理。
    - 对接口进行代理的cglib，最后生成的源码是实现了该接口和Factory接口
    - 对实现类进行代理的cglib，最后生成的源码是继承了实现类并实现了Factory接口
16. final的用途。
    - 当final修饰变量时，被修饰的变量必须被初始化(赋值)，且后续不能修改其值，实质上是常量；
    - 当final修饰方法时，被修饰的方法无法被所在类的子类重写（覆写）；
    - 当final修饰类时，被修饰的类不能被继承，并且final类中的所有成员方法都会被隐式地指定为final方法，但成员变量则不会变
17. 写出三种单例模式实现 。
    ```
        //懒汉式
        public class Singleton{
            private static Singleton instance = null;
            private Singleton(){

            }
            private static Singleton getInstance(){
                if(instance==null){
                    instance = new Singleton();
                }
                return instance;
            }
        }
        //线程不安全
    ```
    ```
        //饿汉式
        public class Singleton {

            private static Singleton instance = new Singleton();

            private Singleton (){}

            public static Singleton getInstance() {
                return instance;
            }

        }
        //线程安全，但不能延迟加载
    ```
    ```
        //双重校验锁
        public class Singleton(){
            private static volatile Singleton instance = null;
            private Singleton(){

            }
            private static Singleton getInstance(){
                if(instance==null){
                    synchronized(Singleton.class){
                        if(instance==null){
                            instance = new Singleton();
                        }
                    }
                }
                return instance;
            }
        }
        //双重校验锁，线程安全，推荐使用

    ```
18. 如何在父类中为子类自动完成所有的hashcode和equals实现？这么做有何优劣。
19. 请结合OO设计理念，谈谈访问修饰符public、private、protected、default在应用设计中的作用。
20. 深拷贝和浅拷贝区别。
    - 基本数据类型：数据存放在栈中
    - 引用数据类型：数据存在堆中，栈中存放的是指针，该指针指向堆中该实体的起始地址
    - 浅拷贝：浅拷贝只复制指向某个对象的指针，而不复制对象本身，新旧对象还是共享同一块内存，实现方式：实现Cloneable类，并重写Object的clone方法，然后在方法内部调用super.clone()方法
    - 深拷贝：深拷贝会另外创造一个一模一样的对象，新对象跟原对象不共享内存，修改新对象不会改到原对象。实现方式：1.需要实现Cloneable接口并且重写clone方法，在方法内部创建一个新的对象；2.通过序列化实现深拷贝
    - 数组的Arrays.copyOf和clone()都是浅拷贝
21. 数组和链表数据结构描述，各自的时间复杂度。
    - (静态)数组从栈中分配空间, 对于程序员方便快速,但自由度小。
    - 链表从堆中分配空间, 自由度大但申请管理比较麻烦。
    - 数组利用下标定位，时间复杂度为O(1)，链表定位元素时间复杂度O(n)；
    - 数组插入或删除元素的时间复杂度O(n)，链表的时间复杂度O(1)
22. error和exception的区别，CheckedException，RuntimeException的区别。
    - error和exception都继承了throwable接口
    - Error类一般是指与虚拟机相关的问题，如系统崩溃，虚拟机错误，内存空间不足，方法调用栈溢等。对于这类错误的导致的应用程序中断，仅靠程序本身无法恢复和预防，遇到这样的错误，建议让程序终止。
    - Exception类表示程序可以处理的异常，可以捕获且可能恢复。遇到这类异常，应该尽可能处理异常，使程序恢复运行，而不应该随意终止异常
    - 检查异常：程序编写时需要try catch住的异常
    - 运行时异常：程序运行时出现的异常

23. 请列出5个运行时异常。

    - ClassCastException（类转换异常）
    - NullPointException
    - IndexOutOfBoundsExcepiton
    - ArrayStoreException
    - IOException

    - 全局异常处理：@ControllerAdvice
    
24. 在自己的代码中，如果创建一个java.lang.String类，这个类是否可以被类加载器加载？为什么。
    - 
25. 说一说你对java.lang.Object对象中hashCode和equals方法的理解。在什么场景下需要重新实现这两个方法。
26. 在jdk1.5中，引入了泛型，泛型的存在是用来解决什么问题。
    - 解决强制类型转换
27. 有没有可能2个不相等的对象有相同的hashcode。

    - 可能

28. Java中的HashSet内部是如何工作的。

    - set是无序的、唯一的，底层使用hashMap的key实现

29. 什么是序列化，怎么序列化，为什么序列化，反序列化会遇到什么问题，如何解决。



---
**JVM知识**
```
1.什么情况下会发生栈内存溢出。
2.JVM的内存结构，Eden和Survivor比例。
3.JVM内存为什么要分成新生代，老年代，持久代。新生代中为什么要分为Eden和Survivor。
4.JVM中一次完整的GC流程是怎样的，对象如何晋升到老年代，说说你知道的几种主要的JVM参数。
5.你知道哪几种垃圾收集器，各自的优缺点，重点讲下cms和G1，包括原理，流程，优缺点。
6.垃圾回收算法的实现原理。
7.当出现了内存溢出，你怎么排错。
8.JVM内存模型的相关知识了解多少，比如重排序，内存屏障，happen-before，主内存，工作内存等。
9.简单说说你了解的类加载器，可以打破双亲委派么，怎么打破。
10.讲讲JAVA的反射机制。
11.你们线上应用的JVM参数有哪些。
12.g1和cms区别,吞吐量优先和响应优先的垃圾收集器选择。
13.怎么打出线程栈信息。
14.请解释如下jvm参数的含义：
15.-server -Xms512m -Xmx512m -Xss1024K
16.-XX:PermSize=256m -XX:MaxPermSize=512m -
17.XX:MaxTenuringThreshold=20XX:CMSInitiatingOccupancyFraction=80 -
18.XX:+UseCMSInitiatingOccupancyOnly。
```
**开源框架知识**
```
1.简单讲讲tomcat结构，以及其类加载器流程，线程模型等。
2.tomcat如何调优，涉及哪些参数 。
3.讲讲Spring加载流程。
4.Spring AOP的实现原理。
5.讲讲Spring事务的传播属性。
6.Spring如何管理事务的。
7.Spring怎么配置事务（具体说出一些关键的xml 元素）。
8.说说你对Spring的理解，非单例注入的原理？它的生命周期？循环注入的原理，aop的实现原理，说说aop中的几个术语，它们是怎么相互工作的。
9.Springmvc 中DispatcherServlet初始化过程。
10.netty的线程模型，netty如何基于reactor模型上实现的。
11.为什么选择netty。
12.什么是TCP粘包，拆包。解决方式是什么。
13.netty的fashwheeltimer的用法，实现原理，是否出现过调用不够准时，怎么解决。
14.netty的心跳处理在弱网下怎么办。
15.netty的通讯协议是什么样的。
16.springmvc用到的注解，作用是什么，原理。
17.springboot启动机制。
```
**操作系统**
```
1.Linux系统下你关注过哪些内核参数，说说你知道的。
2.Linux下IO模型有几种，各自的含义是什么。
3.epoll和poll有什么区别。
4.平时用到哪些Linux命令。
5.用一行命令查看文件的最后五行。
6.用一行命令输出正在运行的java进程。
7.介绍下你理解的操作系统中线程切换过程。
8.进程和线程的区别。
9.top 命令之后有哪些内容，有什么作用。
10.线上CPU爆高，请问你如何找到问题所在。
```
**多线程**

1. 多线程的几种实现方式，什么是线程安全。

    - 继承Thread类，重写run方法，调用start()方法启动线程

    - 实现Runnable接口，new Thread(new Runnable( run())).start()

    - 使用内部类

    - 使用定时器

    - 使用future
        - 当我们提交一个Callable任务后，我们会同时获得一个Future对象，然后，我们在主线程某个时刻调用Future对象的get()方法，就可以获得异步执行的结果。在调用get()时，如果异步任务已经完成，我们就直接获得结果。如果异步任务还没有完成，那么get()会阻塞，直到任务完成后才返回结果。

    - 使用线程池

2.volatile的原理，作用，能代替锁么。

volatile 保证可见性、不保证原子性，禁止指令重排序

i = 0;  // 在 Java 中，对基本数据类型的变量和赋值操作都是原子性操作
j = i ;  // 包含了两个操作：读取 i，将 i 值赋值给 j 。
i++;  // <3>
i = j + 1; // <4>



3.画一个线程的生命周期状态图。
4. sleep和wait的区别。
    
5.sleep和sleep(0)的区别。
6.Lock与Synchronized的区别 。
7. synchronized的原理是什么，一般用在什么地方(比如加在静态方法和非静态方法的区别，静态方法和非静态方法同时执行的时候会有影响吗)，解释以下名词：重排序，自旋锁，偏向锁，轻量级锁，可重入锁，公平锁，非公平锁，乐观锁，悲观锁。

    - synchronized：可重入、非公平锁，代码块是monitorenter、monitorexit，方法是ACC_SYNCHRONIZED标识方法的同步
    - 重排序：指令重排序
    - 偏向锁
        - 未加锁的时候，锁标志为01，包含哈希值、年龄分代和偏向锁标志位(0)
        - 施加偏向锁时，哈希值和一部分无用内存会转化为锁主人的线程信息，以及加锁时的时间戳epoch，此时锁标志位没变，偏向锁标志改为1
        - 加锁时先判断当前线程id是否与MarkWord的线程id是否一致，一致则执行同步代码；不一致则检查偏向标志是否偏向，未偏向则使用CAS加锁；未偏向CAS加锁失败和存在偏向锁会导致偏向锁膨胀为轻量级锁，或者重新偏向
        - 偏向锁只有遇到其他线程竞争偏向锁时，持有偏向锁的线程才会释放锁，线程不会主动去释放偏向锁
    - 轻量级锁
        - 当发生多个线程竞争时，偏向锁会变为轻量级锁，锁标志位为00
        - 获得锁的线程会先将偏向锁撤销(在安全点)，并在栈桢中创建锁记录LockRecord，对象的MarkWord被复制到刚创建的LockRecord，然后CAS尝试将记录LockRecord的owner指向锁对象，再将锁对象的MarkWord指向锁，加锁成功
        - 如果CAS加锁失败，线程会自旋一定次数加锁，再失败则升级为重量级锁
    - 重量级锁
        - 重量级锁就是上面介绍到synchronized使用监视器Monitor实现的锁机制
        - 竞争线程激烈，锁则继续膨胀，变为重量级锁，也是互斥锁，锁标志位为10，MarkWord其余内容被替换为一个指向对象锁Monitor的指针
    - 自旋锁：减少不必要的CPU上下文切换；在轻量级锁升级为重量级锁时，就使用了自旋加锁的方式
    - 锁粗化：多次加锁操作在JVM内部也是种消耗，如果多个加锁可以合并为一个锁，就可减少不必要的开销
    - 锁消除
        - 删除不必要的加锁操作，如果变量是独属一个线程的栈变量，加不加锁都是安全的，编译器会尝试消除锁
        - 开启锁消除需要在JVM参数上设置-server -XX:+DoEscapeAnalysis -XX:+EliminateLocks
    - 悲观锁：每次去请求数据的时候，都认为数据会被抢占更新(悲观的想法)；所以每次操作数据时都要先加上锁，其他线程修改数据时就要等待获取锁。适用于写多读少的场景，synchronized就是一种悲观锁
    - 乐观锁：在请求数据时，觉得无人抢占修改。等真正更新数据时，才判断此期间别人有没有修改过(预先读出一个版本号或者更新时间戳，更新时判断是否变化，没变则期间无人修改)；和悲观锁不同的是，期间数据允许其他线程修改
    - 公平锁：讲究先来先到，线程在获取锁时，如果等待队列中以及有线程在等待，那么当前线程就会进入等待队列中。
    - 非公平锁：不管是否有等待队列，都会去尝试获得锁。

8.用过哪些原子类，他们的原理是什么。
9.JUC下研究过哪些并发工具，讲讲原理。
10.用过线程池吗，如果用过，请说明原理，并说说newCache和newFixed有什么区别，构造函数的各个参数的含义是什么，比如coreSize，maxsize等。
11.线程池的关闭方式有几种，各自的区别是什么。
12.假如有一个第三方接口，有很多个线程去调用获取数据，现在规定每秒钟最多有10个线程同时调用它，如何做到。
13.spring的controller是单例还是多例，怎么保证并发的安全。
14.用三个线程按顺序循环打印abc三个字母，比如abcabcabc。
15. ThreadLocal用过么，用途是什么，原理是什么，用的时候要注意什么。

    - 当使用ThreadLocal声明变量时，ThreadLocal为每个使用该变量的线程提供独立的变量副本，每一个线程都可以独立地改变自己的副本，而不会影响其它线程所对应的副本
    - 从上面的概念可知，ThreadLocal其实并不能保证变量的同步性，只是给每一个线程分配一个变量副本

16.如果让你实现一个并发安全的链表，你会怎么做。
17.有哪些无锁数据结构，他们实现的原理是什么。
18.讲讲java同步机制的wait和notify。
19. CAS机制是什么，如何解决ABA问题。

    - ABA问题
        - 线程X准备将变量的值从A改为B，然而这期间线程Y将变量的值从A改为C，然后再改为A；最后线程X检测变量值是A，并置换为B。但实际上，A已经不再是原来的A了
        - 解决方法，是把变量定为唯一类型。值可以加上版本号，或者时间戳。如加上版本号，线程Y的修改变为A1->B2->A3，此时线程X再更新则可以判断出A1不等于A3
    - 只能保证一个共享变量的原子操作
        - 只保证一个共享变量的原子操作，对多个共享变量同步时，循环CAS是无法保证操作的原子

20. 基于volatile + CAS 实现同步锁的原理

    - CAS只能同步一个变量的修改，我们又应该如何用它来锁住代码块呢？
    - 先说说实现锁的要素
        - 1 同步代码块同一时刻只能有一个线程能执行
        - 2 加锁操作要happens-before同步代码块里的操作，而代码块里的操作要happens-before解锁操作
        - 3 同步代码块结束后相对其他线程其修改的变量是可见的 (内存可见性)
    - 要素1：可以利用CAS的原子性来实现，任意时刻只有一个线程能成功操作变量
        - 先设想CAS操作的共享变量是一个关联代码块的同步状态变量，同步开始之前先CAS更新状态变量为加锁状态，同步结束之后，再CAS状态变量为无锁状态
        - 如果期间有第二个线程来加锁，则会发现状态变量为加锁状态，则放弃执行同步代码块
    - 要素2：使用volatile修饰状态变量，禁止指令重排
        - volatile保证同步代码里的操作happens-before解锁操作，而加锁操作happens-before代码块里的操作
    - 要素3：还是用volatile，volatile变量写指令前后会插入内存屏障
        - volatile修饰的状态变量被CAS为无锁状态前，同步代码块的脏数据就会被更新，被各个线程可见

```
//伪代码
volatile state = 0 ;   // 0-无锁 1-加锁；volatile禁止指令重排，加入内存屏障
...
if(cas(state, 0 , 1)){ // 1 加锁成功，只有一个线程能成功加锁
    ...                // 2 同步代码块
    cas(state, 1, 0);  // 3 解锁时2的操作具有可见性
}

```

20.多线程如果线程挂住了怎么办。
21.countdowlatch和cyclicbarrier的内部原理和用法，以及相互之间的差别(比如countdownlatch的await方法和是怎么实现的)。
22. 对AbstractQueuedSynchronizer(AQS)了解多少，讲讲加锁和解锁的流程，独占锁和公平所加锁有什么不同。

    - AQS其实就是基于volatile+cas实现的锁模板；如果需要线程阻塞等待，唤醒机制，则使用LockSupport挂起、唤醒线程
    - AQS内部维护一个同步队列，元素就是包装了线程的Node
    - 同步队列中首节点是获取到锁的节点，它在释放锁的时会唤醒后继节点，后继节点获取到锁的时候，会把自己设为首节点
    - 线程会先尝试获取锁，失败则封装成Node，CAS加入同步队列的尾部。在加入同步队列的尾部时，会判断前驱节点是否是head结点，并尝试加锁(可能前驱节点刚好释放锁)，否则线程进入阻塞等待
    - volatile+cas机制保证了代码的同步性和可见性，而AQS封装了线程阻塞等待挂起，解锁唤醒其他线程的逻辑。AQS子类只需根据状态变量，判断是否可获取锁，是否释放锁成功即可

23.使用synchronized修饰静态方法和非静态方法有什么区别。
24.简述ConcurrentLinkedQueue和LinkedBlockingQueue的用处和不同之处。
25.导致线程死锁的原因？怎么解除线程死锁。
26.非常多个线程（可能是不同机器），相互之间需要等待协调，才能完成某种工作，问怎么设计这种协调方案。
27.用过读写锁吗，原理是什么，一般在什么场景下用。
28.开启多个线程，如果保证顺序执行，有哪几种实现方式，或者如何保证多个线程都执行完再拿到结果。
29.延迟队列的实现方式，delayQueue和时间轮算法的异同。
30. 守护线程：方法和普通线程一样，只是在调用start()方法前，调用setDaemon(true)把该线程标记为守护线程
31. 中断线程：中断一个线程非常简单，只需要在其他线程中对目标线程调用interrupt()方法，目标线程需要反复检测自身状态是否是interrupted状态，如果是，就立刻结束运行
32. ReentrantLock
    - private final Lock lock = new ReentrantLock(); lock.lock(); lock.unlock();
    - 可以使用tryLock()尝试获取锁。
    

**TCP与HTTP**
1.http1.0和http1.1有什么区别。
2.TCP三次握手和四次挥手的流程，为什么断开连接要4次,如果握手只有两次，会出现什么。
3. TIME_WAIT和CLOSE_WAIT的区别。
4. 说说你知道的几种HTTP响应码，比如200, 302, 404。
    - 200：成功
    - 302：该资源原本确实存在，但已经被临时改变了位置
    - 404：页面不存在
5.当你用浏览器打开一个链接（如：http://www.javastack.cn）的时候，计算机做了哪些工作步骤。
6.TCP/IP如何保证可靠性，说说TCP头的结构。
7.如何避免浏览器缓存。
8.如何理解HTTP协议的无状态性。
9.简述Http请求get和post的区别以及数据包格式。
10.HTTP有哪些method
11.简述HTTP请求的报文格式。
12.HTTP的长连接是什么意思。
13.HTTPS的加密方式是什么，讲讲整个加密解密流程。
14.Http和https的三次握手有什么区别。
15.什么是分块传送。
16.Session和cookie的区别。
**架构设计与分布式**
1. 用java自己实现一个LRU。
    - LRU：Least Recently Used：最近最少使用

2. 分布式集群下如何做到唯一序列号。
    - 数据库自增长序列
    - UUID
    - Redis 生成id
    - Twitter的snowflake
    - 利用zookeeper生成唯一id

3.设计一个秒杀系统，30分钟没付款就自动关闭交易。
4.如何使用redis和zookeeper实现分布式锁？有什么区别优缺点，会有什么问题，分别适用什么场景。（延伸：如果知道redlock，讲讲他的算法实现，争议在哪里）
5.如果有人恶意创建非法连接，怎么解决。
6.分布式事务的原理，优缺点，如何使用分布式事务，2pc 3pc 的区别，解决了哪些问题，还有哪些问题没解决，如何解决，你自己项目里涉及到分布式事务是怎么处理的。
7.什么是一致性hash。
8.什么是restful，讲讲你理解的restful。
9.如何设计一个良好的API。
10.如何设计建立和保持100w的长连接。
11.解释什么是MESI协议(缓存一致性)。
12. 说说你知道的几种HASH算法，简单的也可以。
    - MD5
    - SHA-1
    - SHA-256
    - SHA-512
    - RipeMD-160
13.什么是paxos算法， 什么是zab协议。
14.一个在线文档系统，文档可以被编辑，如何防止多人同时对同一份文档进行编辑更新。
16.线上系统突然变得异常缓慢，你如何查找问题。
17. 说说你平时用到的设计模式。
    - 工厂模式
    - 单例模式
    - 适配器模式
    - 装饰器模式
    - 代理模式
    - 

18.Dubbo的原理，有看过源码么，数据怎么流转的，怎么实现集群，负载均衡，服务注册和发现，重试转发，快速失败的策略是怎样的 。
19.一次RPC请求的流程是什么。
20.自己实现过rpc么，原理可以简单讲讲。Rpc要解决什么问题。
21.异步模式的用途和意义。
22.编程中自己都怎么考虑一些设计原则的，比如开闭原则，以及在工作中的应用。
23.设计一个社交网站中的“私信”功能，要求高并发、可扩展等等。 画一下架构图。
24.MVC模式，即常见的MVC框架。
25.聊下曾经参与设计的服务器架构并画图，谈谈遇到的问题，怎么解决的。
26.应用服务器怎么监控性能，各种方式的区别。
27.如何设计一套高并发支付方案，架构如何设计。
28.如何实现负载均衡，有哪些算法可以实现。
29.Zookeeper的用途，选举的原理是什么。
30.Zookeeper watch机制原理。
31.Mybatis的底层实现原理。
32.请思考一个方案，实现分布式环境下的countDownLatch。
33.后台系统怎么防止请求重复提交。
34.描述一个服务从发布到被消费的详细过程。
35.讲讲你理解的服务治理。
36.如何做到接口的幂等性。
37.如何做限流策略，令牌桶和漏斗算法的使用场景。
38.什么叫数据一致性，你怎么理解数据一致性。
39.分布式服务调用方，不依赖服务提供方的话，怎么处理服务方挂掉后，大量无效资源请求
40.的浪费，如果只是服务提供方吞吐不高的时候该怎么做，如果服务挂了，那么一会重启，该怎么做到最小的资源浪费，流量半开的实现机制是什么。
41.dubbo的泛化调用怎么实现的，如果是你，你会怎么做。
42.远程调用会有超时现象，如果做到优雅的控制，JDK自带的超时机制有哪些，怎么实现的。
**算法**
1. 10亿个数字里里面找最小的10个。
2. 有1亿个数字，其中有2个是重复的，快速找到它，时间和空间要最优。
3. 2亿个随机生成的无序整数,找出中间大小的值。
4. 给一个不知道长度的（可能很大）输入字符串，设计一种方案，将重复的字符排重。
5. 遍历二叉树。
6. 有3n+1个数字，其中3n个中是重复的，只有1个是不重复的，怎么找出来。
7. 写一个字符串（如：www.javastack.cn）反转函数。
8. 常用的排序算法，快排，归并、冒泡。 快排的最优时间复杂度，最差复杂度。冒泡排序的优化方案。
9. 二分查找的时间复杂度，优势。
10. 一个已经构建好的TreeSet，怎么完成倒排序。
11. 什么是B+树，B-树，列出实际的使用场景。
12. 一个单向链表，删除倒数第N个数据。
13. 200个有序的数组，每个数组里面100个元素，找出top20的元素。
14. 单向链表，查找中间的那个元素。
15. PriorityQueue 优先级队列，放入PriorityQueue的元素，必须实现Comparable接口
**数据库知识**
```
1.数据库隔离级别有哪些，各自的含义是什么，MYSQL默认的隔离级别是是什么。
2.什么是幻读。
3.MYSQL有哪些存储引擎，各自优缺点。
4.高并发下，如何做到安全的修改同一行数据。
5.乐观锁和悲观锁是什么，INNODB的标准行级锁有哪2种，解释其含义。
6.SQL优化的一般步骤是什么，怎么看执行计划，如何理解其中各个字段的含义。
7.数据库会死锁吗，举一个死锁的例子，mysql怎么解决死锁。
8.MYsql的索引原理，索引的类型有哪些，如何创建合理的索引，索引如何优化。
9.聚集索引和非聚集索引的区别。
10.select for update 是什么含义，会锁表还是锁行或是其他。
11.为什么要用Btree实现，它是怎么分裂的，什么时候分裂，为什么是平衡的。
12.数据库的ACID是什么。
13.某个表有近千万数据，CRUD比较慢，如何优化。
14.Mysql怎么优化table scan的。
15.如何写sql能够有效的使用到复合索引。
16.mysql中in 和exists 区别。
17.数据库自增主键可能的问题。
18.MVCC的含义，如何实现的。
19.你做过的项目里遇到分库分表了吗，怎么做的，有用到中间件么，比如sharding jdbc等,他们的原理知道么。
20.MYSQL的主从延迟怎么解决。
```
**消息队列**
```
1.消息队列的使用场景。
2.消息的重发，补充策略。
3.如何保证消息的有序性。
4.用过哪些MQ，和其他mq比较有什么优缺点，MQ的连接是线程安全的吗，你们公司的MQ服务架构怎样的。
5.MQ系统的数据如何保证不丢失。
6.rabbitmq如何实现集群高可用。
7.kafka吞吐量高的原因。
8.kafka 和其他消息队列的区别，kafka 主从同步怎么实现。
9.利用mq怎么实现最终一致性。
10.使用kafka有没有遇到什么问题，怎么解决的。
11.MQ有可能发生重复消费，如何避免，如何做到幂等。
12.MQ的消息延迟了怎么处理，消息可以设置过期时间么，过期了你们一般怎么处理。
```
**缓存**
```
1.常见的缓存策略有哪些，如何做到缓存(比如redis)与DB里的数据一致性，你们项目中用到了
2.什么缓存系统，如何设计的。
3.如何防止缓存击穿和雪崩。
4.缓存数据过期后的更新如何设计。
5.redis的list结构相关的操作。
6.Redis的数据结构都有哪些。
7.Redis的使用要注意什么，讲讲持久化方式，内存设置，集群的应用和优劣势，淘汰策略等。
8.redis2和redis3的区别，redis3内部通讯机制。
9.当前redis集群有哪些玩法，各自优缺点，场景。
10.Memcache的原理，哪些数据适合放在缓存中。
11.redis和memcached 的内存管理的区别。
12.Redis的并发竞争问题如何解决，了解Redis事务的CAS操作吗。
13.Redis的选举算法和流程是怎样的。
14.redis的持久化的机制，aof和rdb的区别。
15.redis的集群怎么同步的数据的。
16.知道哪些redis的优化操作。
17.Reids的主从复制机制原理。
18.Redis的线程模型是什么。
19.请思考一个方案，设计一个可以控制缓存总体大小的自动适应的本地缓存。
20.如何看待缓存的使用（本地缓存，集中式缓存），简述本地缓存和集中式缓存和优缺点。
21.本地缓存在并发使用时的注意事项。
```
**搜索**
```
1.elasticsearch了解多少，说说你们公司es的集群架构，索引数据大小，分片有多少，以及一些调优手段 。elasticsearch的倒排索引是什么。
2.elasticsearch 索引数据多了怎么办，如何调优，部署。
3.elasticsearch是如何实现master选举的。
4.详细描述一下Elasticsearch索引文档的过程。
5.详细描述一下Elasticsearch搜索的过程。
6.Elasticsearch在部署时，对Linux的设置有哪些优化方法？
7.lucence内部结构是什么。
```
**参考资料**
[基础篇：详解锁原理，synchronized、volatile+cas底层实现] (https://segmentfault.com/a/1190000023315634)

# 结语

想去鹅厂啊，啊啊啊～